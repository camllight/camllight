\mysection{{\tt unix}: interface to the Unix system }

\label{s:unix}
\index{unix (module)@\verb`unix` (module)}%

\subsection*{Error report }\begin{verbatim}
type error =
    ENOERR
  | EPERM               (* Not owner *)
  | ENOENT              (* No such file or directory *)
  | ESRCH               (* No such process *)
  | EINTR               (* Interrupted system call *)
  | EIO                 (* I/O error *)
  | ENXIO               (* No such device or address *)
  | E2BIG               (* Arg list too long *)
  | ENOEXEC             (* Exec format error *)
  | EBADF               (* Bad file number *)
  | ECHILD              (* No children *)
  | EAGAIN              (* No more processes *)
  | ENOMEM              (* Not enough core *)
  | EACCES              (* Permission denied *)
  | EFAULT              (* Bad address *)
  | ENOTBLK             (* Block device required *)
  | EBUSY               (* Mount device busy *)
  | EEXIST              (* File exists *)
  | EXDEV               (* Cross-device link *)
  | ENODEV              (* No such device *)
  | ENOTDIR             (* Not a directory*)
  | EISDIR              (* Is a directory *)
  | EINVAL              (* Invalid argument *)
  | ENFILE              (* File table overflow *)
  | EMFILE              (* Too many open files *)
  | ENOTTY              (* Not a typewriter *)
  | ETXTBSY             (* Text file busy *)
  | EFBIG               (* File too large *)
  | ENOSPC              (* No space left on device *)
  | ESPIPE              (* Illegal seek *)
  | EROFS               (* Read-only file system *)
  | EMLINK              (* Too many links *)
  | EPIPE               (* Broken pipe *)
  | EDOM                (* Argument too large *)
  | ERANGE              (* Result too large *)
  | EWOULDBLOCK         (* Operation would block *)
  | EINPROGRESS         (* Operation now in progress *)
  | EALREADY            (* Operation already in progress *)
  | ENOTSOCK            (* Socket operation on non-socket *)
  | EDESTADDRREQ        (* Destination address required *)
  | EMSGSIZE            (* Message too long *)
  | EPROTOTYPE          (* Protocol wrong type for socket *)
  | ENOPROTOOPT         (* Protocol not available *)
  | EPROTONOSUPPORT     (* Protocol not supported *)
  | ESOCKTNOSUPPORT     (* Socket type not supported *)
  | EOPNOTSUPP          (* Operation not supported on socket *)
  | EPFNOSUPPORT        (* Protocol family not supported *)
  | EAFNOSUPPORT        (* Address family not supported by protocol family *)
  | EADDRINUSE          (* Address already in use *)
  | EADDRNOTAVAIL       (* Can't assign requested address *)
  | ENETDOWN            (* Network is down *)
  | ENETUNREACH         (* Network is unreachable *)
  | ENETRESET           (* Network dropped connection on reset *)
  | ECONNABORTED        (* Software caused connection abort *)
  | ECONNRESET          (* Connection reset by peer *)
  | ENOBUFS             (* No buffer space available *)
  | EISCONN             (* Socket is already connected *)
  | ENOTCONN            (* Socket is not connected *)
  | ESHUTDOWN           (* Can't send after socket shutdown *)
  | ETOOMANYREFS        (* Too many references: can't splice *)
  | ETIMEDOUT           (* Connection timed out *)
  | ECONNREFUSED        (* Connection refused *)
  | ELOOP               (* Too many levels of symbolic links *)
  | ENAMETOOLONG        (* File name too long *)
  | EHOSTDOWN           (* Host is down *)
  | EHOSTUNREACH        (* No route to host *)
  | ENOTEMPTY           (* Directory not empty *)
  | EPROCLIM            (* Too many processes *)
  | EUSERS              (* Too many users *)
  | EDQUOT              (* Disc quota exceeded *)
  | ESTALE              (* Stale NFS file handle *)
  | EREMOTE             (* Too many levels of remote in path *)
  | EIDRM               (* Identifier removed *)
  | EDEADLK             (* Deadlock condition. *)
  | ENOLCK              (* No record locks available. *)
  | ENOSYS              (* Function not implemented *)
  | EUNKNOWNERR
\end{verbatim}
\begin{comment}
 The type of error codes. 
\end{comment}
\begin{verbatim}
exception Unix_error of error * string * string
\end{verbatim}
\index{Unix_error (exception)@\verb`Unix_error` (exception)}%
\begin{comment}
 Raised by the system calls below when an error is encountered.
           The first component is the error code; the second component
           is the function name; the third component is the string parameter
           to the function, if it has one, or the empty string otherwise. 
\end{comment}
\begin{verbatim}
value error_message : error -> string
\end{verbatim}
\index{error_message@\verb`error_message`}%
\begin{comment}
 Return a string describing the given error code. 
\end{comment}
\begin{verbatim}
value handle_unix_error : ('a -> 'b) -> 'a -> 'b
\end{verbatim}
\index{handle_unix_error@\verb`handle_unix_error`}%
\begin{comment}
 \verbhandle_unix_error f x applies \verbf to \verbx and returns the result.
           If the exception \verbUnix_error is raised, it prints a message
           describing the error and exits with code 2. 
\end{comment}
\subsection*{Interface with the parent process }\begin{verbatim}
value environment : unit -> string vect
\end{verbatim}
\index{environment@\verb`environment`}%
\begin{comment}
 Return the process environment, as an array of strings
           with the format ``variable=value''. See also \verbsys__getenv. 
\end{comment}
\subsection*{Process handling }\begin{verbatim}
type process_status =
    WEXITED of int
  | WSIGNALED of int * bool
  | WSTOPPED of int
\end{verbatim}
\begin{comment}
 The termination status of a process. \verbWEXITED means that the
           process terminated normally by \verbexit; the argument is the return
           code. \verbWSIGNALED means that the process was killed by a signal;
           the first argument is the signal number, the second argument
           indicates whether a ``core dump'' was performed. \verbWSTOPPED means
           that the process was stopped by a signal; the argument is the
           signal number. 
\end{comment}
\begin{verbatim}
type wait_flag =
    WNOHANG
  | WUNTRACED
\end{verbatim}
\begin{comment}
 Flags for \verbwaitopt and \verbwaitpid.
           \verbWNOHANG means do not block if no child has
           died yet, but immediately return with a pid equal to 0.
           \verbWUNTRACED means report also the children that receive stop
           signals. 
\end{comment}
\begin{verbatim}
value execv : string -> string vect -> unit
\end{verbatim}
\index{execv@\verb`execv`}%
\begin{comment}
 \verbexecv prog args execute the program in file \verbprog, with
           the arguments \verbargs, and the current process environment. 
\end{comment}
\begin{verbatim}
value execve : string -> string vect -> string vect -> unit
\end{verbatim}
\index{execve@\verb`execve`}%
\begin{comment}
 Same as \verbexecv, except that the third argument provides the
           environment to the program executed. 
\end{comment}
\begin{verbatim}
value execvp : string -> string vect -> unit
\end{verbatim}
\index{execvp@\verb`execvp`}%
\begin{comment}
 Same as \verbexecv, except that the program is searched in the path. 
\end{comment}
\begin{verbatim}
value fork : unit -> int
\end{verbatim}
\index{fork@\verb`fork`}%
\begin{comment}
 Fork a new process. The returned integer is 0 for the child
           process, the pid of the child process for the parent process. 
\end{comment}
\begin{verbatim}
value wait : unit -> int * process_status
\end{verbatim}
\index{wait@\verb`wait`}%
\begin{comment}
 Wait until one of the children processes die, and return its pid
           and termination status. 
\end{comment}
\begin{verbatim}
value waitopt : wait_flag list -> int * process_status
\end{verbatim}
\index{waitopt@\verb`waitopt`}%
\begin{comment}
 Same as \verbwait, but takes a list of options to avoid blocking,
           or report also stopped children. 
\end{comment}
\begin{verbatim}
value waitpid : wait_flag list -> int -> process_status
\end{verbatim}
\index{waitpid@\verb`waitpid`}%
\begin{comment}
 Same as \verbwaitopt, but waits for the process whose pid is given. 
\end{comment}
\begin{verbatim}
value system : string -> process_status
\end{verbatim}
\index{system@\verb`system`}%
\begin{comment}
 Execute the given command, wait until it terminates, and return
           its termination status. The string is interpreted by the shell
           \verb/bin/sh and therefore can contain redirections, quotes, variables,
           etc. The result \verbWEXITED 127 indicates that the shell couldn't
           be executed. 
\end{comment}
\begin{verbatim}
value getpid : unit -> int
\end{verbatim}
\index{getpid@\verb`getpid`}%
\begin{comment}
 Return the pid of the process. 
\end{comment}
\begin{verbatim}
value getppid : unit -> int
\end{verbatim}
\index{getppid@\verb`getppid`}%
\begin{comment}
 Return the pid of the parent process. 
\end{comment}
\begin{verbatim}
value nice : int -> int
\end{verbatim}
\index{nice@\verb`nice`}%
\begin{comment}
 Change the process priority. The integer argument is added to the
           ``nice'' value. (Higher values of the ``nice'' value mean
           lower priorities.) Return the new nice value. 
\end{comment}
\subsection*{Basic file input/output }\begin{verbatim}
type file_descr
\end{verbatim}
\begin{comment}
 The abstract type of file descriptors. 
\end{comment}
\begin{verbatim}
value stdin : file_descr
value stdout : file_descr
value stderr : file_descr
\end{verbatim}
\index{stdin@\verb`stdin`}%
\index{stdout@\verb`stdout`}%
\index{stderr@\verb`stderr`}%
\begin{comment}
 File descriptors for standard input, standard output and
           standard error. 
\end{comment}
\begin{verbatim}
type open_flag =
    O_RDONLY                            (* Open for reading *)
  | O_WRONLY                            (* Open for writing *)
  | O_RDWR                              (* Open for reading and writing *)
  | O_NDELAY                            (* Open in non-blocking mode *)
  | O_APPEND                            (* Open for append *)
  | O_CREAT                             (* Create if nonexistent *)
  | O_TRUNC                             (* Truncate to 0 length if existing *)
  | O_EXCL                              (* Fail if existing *)
\end{verbatim}
\begin{comment}
 The flags to \verbopen. 
\end{comment}
\begin{verbatim}
type file_perm == int
\end{verbatim}
\begin{comment}
 The type of file access rights. 
\end{comment}
\begin{verbatim}
value open : string -> open_flag list -> file_perm -> file_descr
\end{verbatim}
\index{open@\verb`open`}%
\begin{comment}
 Open the named file with the given flags. Third argument is
           the permissions to give to the file if it is created. Return
           a file descriptor on the named file. 
\end{comment}
\begin{verbatim}
value close : file_descr -> unit
\end{verbatim}
\index{close@\verb`close`}%
\begin{comment}
 Close a file descriptor. 
\end{comment}
\begin{verbatim}
value read : file_descr -> string -> int -> int -> int
\end{verbatim}
\index{read@\verb`read`}%
\begin{comment}
 \verbread fd buff start len reads \verblen characters from descriptor
           \verbfd, storing them in string \verbbuff, starting at position \verbofs
           in string \verbbuff. Return the number of characters actually read. 
\end{comment}
\begin{verbatim}
value write : file_descr -> string -> int -> int -> int
\end{verbatim}
\index{write@\verb`write`}%
\begin{comment}
 \verbwrite fd buff start len writes \verblen characters to descriptor
           \verbfd, taking them from string \verbbuff, starting at position \verbofs
           in string \verbbuff. Return the number of characters actually
           written. 
\end{comment}
\subsection*{Interfacing with the standard input/output library (module io). }\begin{verbatim}
value in_channel_of_descr : file_descr -> in_channel
\end{verbatim}
\index{in_channel_of_descr@\verb`in_channel_of_descr`}%
\begin{comment}
 Create an input channel reading from the given descriptor. 
\end{comment}
\begin{verbatim}
value out_channel_of_descr : file_descr -> out_channel
\end{verbatim}
\index{out_channel_of_descr@\verb`out_channel_of_descr`}%
\begin{comment}
 Create an output channel writing on the given descriptor. 
\end{comment}
\begin{verbatim}
value descr_of_in_channel : in_channel -> file_descr
\end{verbatim}
\index{descr_of_in_channel@\verb`descr_of_in_channel`}%
\begin{comment}
 Return the descriptor corresponding to an input channel. 
\end{comment}
\begin{verbatim}
value descr_of_out_channel : out_channel -> file_descr
\end{verbatim}
\index{descr_of_out_channel@\verb`descr_of_out_channel`}%
\begin{comment}
 Return the descriptor corresponding to an output channel. 
\end{comment}
\subsection*{Seeking and truncating }\begin{verbatim}
type seek_command =
    SEEK_SET
  | SEEK_CUR
  | SEEK_END
\end{verbatim}
\begin{comment}
 Positioning modes for \verblseek. \verbSEEK_SET indicates positions
           relative to the beginning of the file, \verbSEEK_CUR relative to
           the current position, \verbSEEK_END relative to the end of the
           file. 
\end{comment}
\begin{verbatim}
value lseek : file_descr -> int -> seek_command -> int
\end{verbatim}
\index{lseek@\verb`lseek`}%
\begin{comment}
 Set the current position for a file descriptor 
\end{comment}
\begin{verbatim}
value truncate : string -> int -> unit
\end{verbatim}
\index{truncate@\verb`truncate`}%
\begin{comment}
 Truncates the named file to the given size. 
\end{comment}
\begin{verbatim}
value ftruncate : file_descr -> int -> unit
\end{verbatim}
\index{ftruncate@\verb`ftruncate`}%
\begin{comment}
 Truncates the file corresponding to the given descriptor
           to the given size. 
\end{comment}
\subsection*{File statistics }\begin{verbatim}
type file_kind =
    S_REG                               (* Regular file *)
  | S_DIR                               (* Directory *)
  | S_CHR                               (* Character device *)
  | S_BLK                               (* Block device *)
  | S_LNK                               (* Symbolic link *)
  | S_FIFO                              (* Named pipe *)
  | S_SOCK                              (* Socket *)
type stats =
  { st_dev : int;                       (* Device number *)
    st_ino : int;                       (* Inode number *)
    st_kind : file_kind;                (* Kind of the file *)
    st_perm : file_perm;                (* Access rights *)
    st_nlink : int;                     (* Number of links *)
    st_uid : int;                       (* User id of the owner *)
    st_gid : int;                       (* Group id of the owner *)
    st_rdev : int;                      (* Device minor number *)
    st_size : int;                      (* Size in bytes *)
    st_atime : int;                     (* Last access time *)
    st_mtime : int;                     (* Last modification time *)
    st_ctime : int }                    (* Last status change time *)
\end{verbatim}
\begin{comment}
 The informations returned by the \verbstat calls. 
\end{comment}
\begin{verbatim}
value stat : string -> stats
\end{verbatim}
\index{stat@\verb`stat`}%
\begin{comment}
 Return the information for the named file. 
\end{comment}
\begin{verbatim}
value lstat : string -> stats
\end{verbatim}
\index{lstat@\verb`lstat`}%
\begin{comment}
 Same as \verbstat, but in case the file is a symbolic link,
           return the information for the link itself. 
\end{comment}
\begin{verbatim}
value fstat : file_descr -> stats
\end{verbatim}
\index{fstat@\verb`fstat`}%
\begin{comment}
 Return the information for the file associated with the given
           descriptor. 
\end{comment}
\subsection*{Operations on file names }\begin{verbatim}
value unlink : string -> unit
\end{verbatim}
\index{unlink@\verb`unlink`}%
\begin{comment}
 Removes the named file 
\end{comment}
\begin{verbatim}
value rename : string -> string -> unit
\end{verbatim}
\index{rename@\verb`rename`}%
\begin{comment}
 \verbrename old new changes the name of a file from \verbold to \verbnew. 
\end{comment}
\begin{verbatim}
value link : string -> string -> unit
\end{verbatim}
\index{link@\verb`link`}%
\begin{comment}
 \verblink source dest creates a hard link named \verbdest to the file
           named \verbnew. 
\end{comment}
\subsection*{File permissions and ownership }\begin{verbatim}
type access_permission =
    R_OK                                (* Read permission *)
  | W_OK                                (* Write permission *)
  | X_OK                                (* Execution permission *)
  | F_OK                                (* File exists *)
\end{verbatim}
\begin{comment}
 Flags for the \verbaccess call. 
\end{comment}
\begin{verbatim}
value chmod : string -> file_perm -> unit
\end{verbatim}
\index{chmod@\verb`chmod`}%
\begin{comment}
 Change the permissions of the named file. 
\end{comment}
\begin{verbatim}
value fchmod : file_descr -> file_perm -> unit
\end{verbatim}
\index{fchmod@\verb`fchmod`}%
\begin{comment}
 Change the permissions of an opened file. 
\end{comment}
\begin{verbatim}
value chown : string -> int -> int -> unit
\end{verbatim}
\index{chown@\verb`chown`}%
\begin{comment}
 Change the owner uid and owner gid of the named file. 
\end{comment}
\begin{verbatim}
value fchown : file_descr -> int -> int -> unit
\end{verbatim}
\index{fchown@\verb`fchown`}%
\begin{comment}
 Change the owner uid and owner gid of an opened file. 
\end{comment}
\begin{verbatim}
value umask : int -> int
\end{verbatim}
\index{umask@\verb`umask`}%
\begin{comment}
 Set the process creation mask, and return the previous mask. 
\end{comment}
\begin{verbatim}
value access : string -> access_permission list -> unit
\end{verbatim}
\index{access@\verb`access`}%
\begin{comment}
 Check that the process has the given permissions over the named
           file. Raise \verbUnix_error otherwise. 
\end{comment}
\subsection*{File descriptor hacking }\begin{verbatim}
value fcntl_int : file_descr -> int -> int -> int
\end{verbatim}
\index{fcntl_int@\verb`fcntl_int`}%
\begin{comment}
 Interface to \verbfcntl in the case where the argument is an
           integer. The first integer argument is the command code;
           the second is the integer parameter. 
\end{comment}
\begin{verbatim}
value fcntl_ptr : file_descr -> int -> string -> int
\end{verbatim}
\index{fcntl_ptr@\verb`fcntl_ptr`}%
\begin{comment}
 Interface to \verbfcntl in the case where the argument is a pointer.
           The integer argument is the command code. A pointer to the string
           argument is passed as argument to the command. The string argument
           is usually set up with the functions from modules \verbpeek and
           \verbpoke. 
\end{comment}
\subsection*{Directories }\begin{verbatim}
value mkdir : string -> file_perm -> unit
\end{verbatim}
\index{mkdir@\verb`mkdir`}%
\begin{comment}
 Create a directory with the given permissions. 
\end{comment}
\begin{verbatim}
value chdir : string -> unit
\end{verbatim}
\index{chdir@\verb`chdir`}%
\begin{comment}
 Change the process working directory. 
\end{comment}
\begin{verbatim}
value rmdir : string -> unit
\end{verbatim}
\index{rmdir@\verb`rmdir`}%
\begin{comment}
 Remove an empty directory. 
\end{comment}
\begin{verbatim}
type dir_handle
\end{verbatim}
\begin{comment}
 The type of descriptors over opened directories. 
\end{comment}
\begin{verbatim}
value opendir : string -> dir_handle
\end{verbatim}
\index{opendir@\verb`opendir`}%
\begin{comment}
 Open a descriptor on a directory 
\end{comment}
\begin{verbatim}
value readdir : dir_handle -> string
\end{verbatim}
\index{readdir@\verb`readdir`}%
\begin{comment}
 Return the next entry in a directory 
\end{comment}
\begin{verbatim}
value rewinddir : dir_handle -> unit
\end{verbatim}
\index{rewinddir@\verb`rewinddir`}%
\begin{comment}
 Reposition the descriptor to the beginning of the directory 
\end{comment}
\begin{verbatim}
value closedir : dir_handle -> unit
\end{verbatim}
\index{closedir@\verb`closedir`}%
\begin{comment}
 Close a directory descriptor. 
\end{comment}
\subsection*{Pipes and redirections }\begin{verbatim}
value pipe : unit -> file_descr * file_descr
\end{verbatim}
\index{pipe@\verb`pipe`}%
\begin{comment}
 Create a pipe. The first component of the result is opened
           for reading, that's the exit to the pipe. The second component is
           opened for writing, that's the entrace to the pipe. 
\end{comment}
\begin{verbatim}
value dup : file_descr -> file_descr
\end{verbatim}
\index{dup@\verb`dup`}%
\begin{comment}
 Duplicate a descriptor. 
\end{comment}
\begin{verbatim}
value dup2 : file_descr -> file_descr -> unit
\end{verbatim}
\index{dup2@\verb`dup2`}%
\begin{comment}
 \verbdup2 fd1 fd2 duplicates \verbfd1 to \verbfd2, closing \verbfd2 if already
           opened. 
\end{comment}
\begin{verbatim}
value open_process_in: string -> in_channel
value open_process_out: string -> out_channel
value open_process: string -> in_channel * out_channel
\end{verbatim}
\index{open_process_in@\verb`open_process_in`}%
\index{open_process_out@\verb`open_process_out`}%
\index{open_process@\verb`open_process`}%
\begin{comment}
 High-level pipe and process management. These functions
           run the given command in parallel with the program,
           and return channels connected to the standard input and/or
           the standard output of the command. The command is interpreted
           by the shell \verb/bin/sh (cf. \verbsystem). Warning: writes on channels
           are buffered, hence be careful to call \verbflush at the right times
           to ensure correct synchronization. 
\end{comment}
\begin{verbatim}
value close_process_in: in_channel -> process_status
value close_process_out: out_channel -> process_status
value close_process: in_channel * out_channel -> process_status
\end{verbatim}
\index{close_process_in@\verb`close_process_in`}%
\index{close_process_out@\verb`close_process_out`}%
\index{close_process@\verb`close_process`}%
\begin{comment}
 Close channels opened by \verbopen_process_in, \verbopen_process_out
           and \verbopen_process, respectively, wait for the associated
           command to terminate, and return its termination status. 
\end{comment}
\subsection*{Symbolic links }\begin{verbatim}
value symlink : string -> string -> unit
\end{verbatim}
\index{symlink@\verb`symlink`}%
\begin{comment}
 \verbsymlink source dest creates the file \verbdest as a symbolic link
           to the file \verbsource. 
\end{comment}
\begin{verbatim}
value readlink : string -> string
\end{verbatim}
\index{readlink@\verb`readlink`}%
\begin{comment}
 Read the contents of a link. 
\end{comment}
\subsection*{Named pipes }\begin{verbatim}
value mkfifo : string -> file_perm -> unit
\end{verbatim}
\index{mkfifo@\verb`mkfifo`}%
\begin{comment}
 Create a named pipe with the given permissions. 
\end{comment}
\subsection*{Special files }\begin{verbatim}
value ioctl_int : file_descr -> int -> int -> int
\end{verbatim}
\index{ioctl_int@\verb`ioctl_int`}%
\begin{comment}
 Interface to \verbioctl in the case where the argument is an
           integer. The first integer argument is the command code;
           the second is the integer parameter. 
\end{comment}
\begin{verbatim}
value ioctl_ptr : file_descr -> int -> string -> int
\end{verbatim}
\index{ioctl_ptr@\verb`ioctl_ptr`}%
\begin{comment}
 Interface to \verbioctl in the case where the argument is a pointer.
           The integer argument is the command code. A pointer to the string
           argument is passed as argument to the command. The string argument
           is usually set up with the functions from modules \verbpeek and
           \verbpoke. 
\end{comment}
\subsection*{Polling }\begin{verbatim}
value select :
  file_descr list -> file_descr list -> file_descr list -> float ->
        file_descr list * file_descr list * file_descr list
\end{verbatim}
\index{select@\verb`select`}%
\begin{comment}
 Wait until some input/output operations become possible on
           some channels. The three list arguments are, respectively, a set
           of descriptors to check for reading (first argument), for writing
           (second argument), or for exceptional conditions (third argument).
           The fourth argument is the maximal timeout, in seconds; a
           negative fourth argument means no timeout (unbounded wait).
           The result is composed of three sets of descriptors: those ready
           for reading (first component), ready for writing (second component),
           and over which an exceptional condition is pending (third
           component). 
\end{comment}
\subsection*{Locking }\begin{verbatim}
type lock_command =
    F_ULOCK               (* Unlock a region *)
  | F_LOCK                (* Lock a region, and block if already locked *)
  | F_TLOCK               (* Lock a region, or fail if already locked *)
  | F_TEST                (* Test a region for other process' locks *)
\end{verbatim}
\begin{comment}
 Commands for \verblockf. 
\end{comment}
\begin{verbatim}
value lockf : file_descr -> lock_command -> int -> unit
\end{verbatim}
\index{lockf@\verb`lockf`}%
\begin{comment}
 \verblockf fd cmd size puts a lock on a region of the file opened
           as \verbfd. The region starts at the current read/write position for
           \verbfd (as set by \verblseek), and extends \verbsize bytes forward if
           \verbsize is positive, \verbsize bytes backwards if \verbsize is negative,
           or to the end of the file if \verbsize is zero. 
\end{comment}
\subsection*{Signals }\begin{verbatim}
type signal =
    SIGHUP              (* hangup *)
  | SIGINT              (* interrupt *)
  | SIGQUIT             (* quit *)
  | SIGILL              (* illegal instruction (not reset when caught) *)
  | SIGTRAP             (* trace trap (not reset when caught) *)
  | SIGABRT             (* used by abort *)
  | SIGEMT              (* EMT instruction *)
  | SIGFPE              (* floating point exception *)
  | SIGKILL             (* kill (cannot be caught or ignored) *)
  | SIGBUS              (* bus error *)
  | SIGSEGV             (* segmentation violation *)
  | SIGSYS              (* bad argument to system call *)
  | SIGPIPE             (* write on a pipe with no one to read it *)
  | SIGALRM             (* alarm clock *)
  | SIGTERM             (* software termination signal from kill *)
  | SIGURG              (* urgent condition on IO channel *)
  | SIGSTOP             (* sendable stop signal not from tty *)
  | SIGTSTP             (* stop signal from tty *)
  | SIGCONT             (* continue a stopped process *)
  | SIGCHLD             (* to parent on child stop or exit *)
  | SIGIO               (* input/output possible signal *)
  | SIGXCPU             (* exceeded CPU time limit *)
  | SIGXFSZ             (* exceeded file size limit *)
  | SIGVTALRM           (* virtual time alarm *)
  | SIGPROF             (* profiling time alarm *)
  | SIGWINCH            (* window changed *)
  | SIGLOST             (* resource lost (eg, record-lock lost) *)
  | SIGUSR1             (* user defined signal 1 *)
  | SIGUSR2             (* user defined signal 2 *)
\end{verbatim}
\begin{comment}
 The type of signals. 
\end{comment}
\begin{verbatim}
type signal_handler =
    Signal_default                      (* Default behavior for the signal *)
  | Signal_ignore                       (* Ignore the signal *)
  | Signal_handle of (unit -> unit)     (* Call the given function
                                           when the signal occurs. *)
\end{verbatim}
\begin{comment}
 The behavior on receipt of a signal 
\end{comment}
\begin{verbatim}
value kill : int -> signal -> unit
\end{verbatim}
\index{kill@\verb`kill`}%
\begin{comment}
 Send a signal to the process with the given process id. 
\end{comment}
\begin{verbatim}
value signal : signal -> signal_handler -> unit
\end{verbatim}
\index{signal@\verb`signal`}%
\begin{comment}
 Set the behavior to be taken on receipt of the given signal. 
\end{comment}
\begin{verbatim}
value pause : unit -> unit
\end{verbatim}
\index{pause@\verb`pause`}%
\begin{comment}
 Wait until a non-ignored signal is delivered. 
\end{comment}
\subsection*{Time functions }\begin{verbatim}
type process_times =
  { tms_utime : float;          (* User time for the process *)
    tms_stime : float;          (* System time for the process *)
    tms_cutime : float;         (* User time for the children processes *)
    tms_cstime : float }        (* System time for the children processes *)
\end{verbatim}
\begin{comment}
 The execution times (CPU times) of a process. 
\end{comment}
\begin{verbatim}
type tm =
  { tm_sec : int;                       (* Seconds 0..59 *)
    tm_min : int;                       (* Minutes 0..59 *)
    tm_hour : int;                      (* Hours 0..23 *)
    tm_mday : int;                      (* Day of month 1..31 *)
    tm_mon : int;                       (* Month of year 0..11 *)
    tm_year : int;                      (* Year - 1900 *)
    tm_wday : int;                      (* Day of week (Sunday is 0) *)
    tm_yday : int;                      (* Day of year 0..365 *)
    tm_isdst : bool }                   (* Daylight time savings in effect *)
\end{verbatim}
\begin{comment}
 The type representing wallclock time and calendar date. 
\end{comment}
\begin{verbatim}
value time : unit -> int
\end{verbatim}
\index{time@\verb`time`}%
\begin{comment}
 Return the current time since 00:00:00 GMT, Jan. 1, 1970,
           in seconds. 
\end{comment}
\begin{verbatim}
value gmtime : int -> tm
\end{verbatim}
\index{gmtime@\verb`gmtime`}%
\begin{comment}
 Convert a time in seconds, as returned by \verbtime, into a date and
           a time. Assumes Greenwich meridian time zone. 
\end{comment}
\begin{verbatim}
value localtime : int -> tm
\end{verbatim}
\index{localtime@\verb`localtime`}%
\begin{comment}
 Convert a time in seconds, as returned by \verbtime, into a date and
           a time. Assumes the local time zone. 
\end{comment}
\begin{verbatim}
value alarm : int -> int
\end{verbatim}
\index{alarm@\verb`alarm`}%
\begin{comment}
 Schedule a \verbSIGALRM signals after the given number of seconds. 
\end{comment}
\begin{verbatim}
value sleep : int -> unit
\end{verbatim}
\index{sleep@\verb`sleep`}%
\begin{comment}
 Stop execution for the given number of seconds. 
\end{comment}
\begin{verbatim}
value times : unit -> process_times
\end{verbatim}
\index{times@\verb`times`}%
\begin{comment}
 Return the execution times of the process. 
\end{comment}
\begin{verbatim}
value utimes : string -> int -> int -> unit
\end{verbatim}
\index{utimes@\verb`utimes`}%
\begin{comment}
 Set the last access time (second arg) and last modification time
           (third arg) for a file. Times are expressed in seconds from
           00:00:00 GMT, Jan. 1, 1970. 
\end{comment}
\subsection*{User id, group id }\begin{verbatim}
value getuid : unit -> int
\end{verbatim}
\index{getuid@\verb`getuid`}%
\begin{comment}
 Return the user id of the user executing the process. 
\end{comment}
\begin{verbatim}
value geteuid : unit -> int
\end{verbatim}
\index{geteuid@\verb`geteuid`}%
\begin{comment}
 Return the effective user id under which the process runs. 
\end{comment}
\begin{verbatim}
value setuid : int -> unit
\end{verbatim}
\index{setuid@\verb`setuid`}%
\begin{comment}
 Set the real user id and effective user id for the process. 
\end{comment}
\begin{verbatim}
value getgid : unit -> int
\end{verbatim}
\index{getgid@\verb`getgid`}%
\begin{comment}
 Return the group id of the user executing the process. 
\end{comment}
\begin{verbatim}
value getegid : unit -> int
\end{verbatim}
\index{getegid@\verb`getegid`}%
\begin{comment}
 Return the effective group id under which the process runs. 
\end{comment}
\begin{verbatim}
value setgid : int -> unit
\end{verbatim}
\index{setgid@\verb`setgid`}%
\begin{comment}
 Set the real group id and effective group id for the process. 
\end{comment}
\begin{verbatim}
value getgroups : unit -> int list
\end{verbatim}
\index{getgroups@\verb`getgroups`}%
\begin{comment}
 Return the list of groups to which the user executing the process
           belongs. 
\end{comment}
\begin{verbatim}
type passwd_entry =
  { pw_name : string;
    pw_passwd : string;
    pw_uid : int;
    pw_gid : int;
    pw_gecos : string;
    pw_dir : string;
    pw_shell : string }
\end{verbatim}
\begin{comment}
 Structure of entries in the \verbpasswd database. 
\end{comment}
\begin{verbatim}
type group_entry =
  { gr_name : string;
    gr_passwd : string;
    gr_gid : int;
    gr_mem : string vect }
\end{verbatim}
\begin{comment}
 Structure of entries in the \verbgroups database. 
\end{comment}
\begin{verbatim}
value getlogin : unit -> string
\end{verbatim}
\index{getlogin@\verb`getlogin`}%
\begin{comment}
 Return the login name of the user executing the process. 
\end{comment}
\begin{verbatim}
value getpwnam : string -> passwd_entry
\end{verbatim}
\index{getpwnam@\verb`getpwnam`}%
\begin{comment}
 Find an entry in \verbpasswd with the given name, or raise
           \verbNot_found. 
\end{comment}
\begin{verbatim}
value getgrnam : string -> group_entry
\end{verbatim}
\index{getgrnam@\verb`getgrnam`}%
\begin{comment}
 Find an entry in \verbgroup with the given name, or raise
           \verbNot_found. 
\end{comment}
\begin{verbatim}
value getpwuid : int -> passwd_entry
\end{verbatim}
\index{getpwuid@\verb`getpwuid`}%
\begin{comment}
 Find an entry in \verbpasswd with the given user id, or raise
           \verbNot_found. 
\end{comment}
\begin{verbatim}
value getgrgid : int -> group_entry
\end{verbatim}
\index{getgrgid@\verb`getgrgid`}%
\begin{comment}
 Find an entry in \verbgroup with the given group id, or raise
           \verbNot_found. 
\end{comment}
\subsection*{Internet addresses }\begin{verbatim}
type inet_addr
\end{verbatim}
\begin{comment}
 The abstract type of Internet addresses. 
\end{comment}
\begin{verbatim}
value inet_addr_of_string : string -> inet_addr
value string_of_inet_addr : inet_addr -> string
\end{verbatim}
\index{inet_addr_of_string@\verb`inet_addr_of_string`}%
\index{string_of_inet_addr@\verb`string_of_inet_addr`}%
\begin{comment}
 Conversions between string with the format \verbXXX.YYY.ZZZ.TTT
           and Internet addresses. \verbinet_addr_of_string raises \verbFailure
           when given a string that does not match this format. 
\end{comment}
\subsection*{Sockets }\begin{verbatim}
type socket_domain =
    PF_UNIX                             (* Unix domain *)
  | PF_INET                             (* Internet domain *)
\end{verbatim}
\begin{comment}
 The type of socket domains. 
\end{comment}
\begin{verbatim}
type socket_type =
    SOCK_STREAM                         (* Stream socket *)
  | SOCK_DGRAM                          (* Datagram socket *)
  | SOCK_RAW                            (* Raw socket *)
  | SOCK_SEQPACKET                      (* Sequenced packets socket *)
\end{verbatim}
\begin{comment}
 The type of socket kinds, specifying the semantics of
           communications. 
\end{comment}
\begin{verbatim}
type sockaddr =
    ADDR_UNIX of string
  | ADDR_INET of inet_addr * int
\end{verbatim}
\begin{comment}
 The type of socket addresses. \verbADDR_UNIX name is a socket
           address in the Unix domain; \verbname is a file name in the file
           system. \verbADDR_INET(addr,port) is a socket address in the Internet
           domain; \verbaddr is the Internet address of the machine, and
           \verbport is the port number. 
\end{comment}
\begin{verbatim}
type shutdown_command =
    SHUTDOWN_RECEIVE                    (* Close for receiving *)
  | SHUTDOWN_SEND                       (* Close for sending *)
  | SHUTDOWN_ALL                        (* Close both *)
\end{verbatim}
\begin{comment}
 The type of commands for \verbshutdown. 
\end{comment}
\begin{verbatim}
type msg_flag =
    MSG_OOB
  | MSG_DONTROUTE
  | MSG_PEEK
\end{verbatim}
\begin{comment}
 The flags for \verbrecv, \verbrecvfrom, \verbsend and \verbsendto. 
\end{comment}
\begin{verbatim}
value socket : socket_domain -> socket_type -> int -> file_descr
\end{verbatim}
\index{socket@\verb`socket`}%
\begin{comment}
 Create a new socket in the given domain, and with the
           given kind. The third argument is the protocol type; 0 selects
           the default protocol for that kind of sockets. 
\end{comment}
\begin{verbatim}
value socketpair :
        socket_domain -> socket_type -> int -> file_descr * file_descr
\end{verbatim}
\index{socketpair@\verb`socketpair`}%
\begin{comment}
 Create a pair of unnamed sockets, connected together. 
\end{comment}
\begin{verbatim}
value accept : file_descr -> file_descr * sockaddr
\end{verbatim}
\index{accept@\verb`accept`}%
\begin{comment}
 Accept connections on the given socket. The returned descriptor
           is a socket connected to the client; the returned address is
           the address of the connecting client. 
\end{comment}
\begin{verbatim}
value bind : file_descr -> sockaddr -> unit
\end{verbatim}
\index{bind@\verb`bind`}%
\begin{comment}
 Bind a socket to an address. 
\end{comment}
\begin{verbatim}
value connect : file_descr -> sockaddr -> unit
\end{verbatim}
\index{connect@\verb`connect`}%
\begin{comment}
 Connect a socket to an address. 
\end{comment}
\begin{verbatim}
value listen : file_descr -> int -> unit
\end{verbatim}
\index{listen@\verb`listen`}%
\begin{comment}
 Set up a socket for receiving connection requests. The integer
           argument is the maximal number of pending requests. 
\end{comment}
\begin{verbatim}
value shutdown : file_descr -> shutdown_command -> unit
\end{verbatim}
\index{shutdown@\verb`shutdown`}%
\begin{comment}
 Shutdown a socket connection. \verbSHUTDOWN_SEND as second argument
           causes reads on the other end of the connection to return
           an end-of-file condition.
           \verbSHUTDOWN_RECEIVE causes writes on the other end of the connection
           to return a closed pipe condition (\verbSIGPIPE signal). 
\end{comment}
\begin{verbatim}
value recv : file_descr -> string -> int -> int -> msg_flag list -> int
value recvfrom :
        file_descr -> string -> int -> int -> msg_flag list -> int * sockaddr
\end{verbatim}
\index{recv@\verb`recv`}%
\index{recvfrom@\verb`recvfrom`}%
\begin{comment}
 Receive data from an unconnected socket. 
\end{comment}
\begin{verbatim}
value send : file_descr -> string -> int -> int -> msg_flag list -> int
value sendto :
        file_descr -> string -> int -> int -> msg_flag list -> sockaddr -> int
\end{verbatim}
\index{send@\verb`send`}%
\index{sendto@\verb`sendto`}%
\begin{comment}
 Send data over an unconnected socket. 
\end{comment}
\subsection*{High-level network connection functions }\begin{verbatim}
value open_connection : sockaddr -> in_channel * out_channel
\end{verbatim}
\index{open_connection@\verb`open_connection`}%
\begin{comment}
 Connect to a server at the given address.
           Return a pair of buffered channels connected to the server.
           Remember to call \verbflush on the output channel at the right times
           to ensure correct synchronization. 
\end{comment}
\begin{verbatim}
value shutdown_connection : in_channel -> unit
\end{verbatim}
\index{shutdown_connection@\verb`shutdown_connection`}%
\begin{comment}
 ``Shut down'' a connection established with \verbopen_connection;
           that is, transmit an end-of-file condition to the server reading
           on the other side of the connection. 
\end{comment}
\begin{verbatim}
value establish_server : (in_channel -> out_channel -> 'a) -> sockaddr -> unit
\end{verbatim}
\index{establish_server@\verb`establish_server`}%
\begin{comment}
 Establish a server on the given address.
           The function given as first argument is called for each connection
           with two buffered channels connected to the client. A new process
           is created for each connection. The function \verbestablish_server
           never returns normally. 
\end{comment}
\subsection*{Host and protocol databases }\begin{verbatim}
type host_entry =
  { h_name : string;
    h_aliases : string vect;
    h_addrtype : socket_domain;
    h_addr_list : inet_addr vect }
\end{verbatim}
\begin{comment}
 Structure of entries in the \verbhosts database. 
\end{comment}
\begin{verbatim}
type protocol_entry =
  { p_name : string;
    p_aliases : string vect;
    p_proto : int }
\end{verbatim}
\begin{comment}
 Structure of entries in the \verbprotocols database. 
\end{comment}
\begin{verbatim}
type service_entry =
  { s_name : string;
    s_aliases : string vect;
    s_port : int;
    s_proto : string }
\end{verbatim}
\begin{comment}
 Structure of entries in the \verbservices database. 
\end{comment}
\begin{verbatim}
value gethostname : unit -> string
\end{verbatim}
\index{gethostname@\verb`gethostname`}%
\begin{comment}
 Return the name of the local host. 
\end{comment}
\begin{verbatim}
value gethostbyname : string -> host_entry
\end{verbatim}
\index{gethostbyname@\verb`gethostbyname`}%
\begin{comment}
 Find an entry in \verbhosts with the given name, or raise
           \verbNot_found. 
\end{comment}
\begin{verbatim}
value gethostbyaddr : inet_addr -> host_entry
\end{verbatim}
\index{gethostbyaddr@\verb`gethostbyaddr`}%
\begin{comment}
 Find an entry in \verbhosts with the given address, or raise
           \verbNot_found. 
\end{comment}
\begin{verbatim}
value getprotobyname : string -> protocol_entry
\end{verbatim}
\index{getprotobyname@\verb`getprotobyname`}%
\begin{comment}
 Find an entry in \verbprotocols with the given name, or raise
           \verbNot_found. 
\end{comment}
\begin{verbatim}
value getprotobynumber : int -> protocol_entry
\end{verbatim}
\index{getprotobynumber@\verb`getprotobynumber`}%
\begin{comment}
 Find an entry in \verbprotocols with the given protocol number,
           or raise \verbNot_found. 
\end{comment}
\begin{verbatim}
value getservbyname : string -> string -> service_entry
\end{verbatim}
\index{getservbyname@\verb`getservbyname`}%
\begin{comment}
 Find an entry in \verbservices with the given name, or raise
           \verbNot_found. 
\end{comment}
\begin{verbatim}
value getservbyport : int -> string -> service_entry
\end{verbatim}
\index{getservbyport@\verb`getservbyport`}%
\begin{comment}
 Find an entry in \verbservices with the given service number,
           or raise \verbNot_found. 
\end{comment}
\subsection*{Terminal interface }\begin{comment}
 The following functions implement the POSIX standard terminal
   interface. They provide control over asynchronous communication ports
   and pseudo-terminals. Refer to the \verbtermios man page for a
   complete description. 
\end{comment}
\begin{verbatim}
type terminal_io = {
\end{verbatim}
\begin{comment}
 Input modes: 
\end{comment}
\begin{verbatim}
    mutable c_ignbrk: bool;  (* Ignore the break condition. *)
    mutable c_brkint: bool;  (* Signal interrupt on break condition. *)
    mutable c_ignpar: bool;  (* Ignore characters with parity errors. *)
    mutable c_parmrk: bool;  (* Mark parity errors. *)
    mutable c_inpck: bool;   (* Enable parity check on input. *)
    mutable c_istrip: bool;  (* Strip 8th bit on input characters. *)
    mutable c_inlcr: bool;   (* Map NL to CR on input. *)
    mutable c_igncr: bool;   (* Ignore CR on input. *)
    mutable c_icrnl: bool;   (* Map CR to NL on input. *)
    mutable c_ixon: bool;    (* Recognize XON/XOFF characters on input. *)
    mutable c_ixoff: bool;   (* Emit XON/XOFF chars to control input flow. *)
\end{verbatim}
\begin{comment}
 Output modes: 
\end{comment}
\begin{verbatim}
    mutable c_opost: bool;   (* Enable output processing. *)
    mutable c_olcuc: bool;   (* Map lowercase to uppercase on output. *)
    mutable c_onlcr: bool;   (* Map NL to CR/NL on output. *)
    mutable c_ocrnl: bool;   (* Map CR to NL on output. *)
    mutable c_onocr: bool;   (* No CR output at column 0. *)
    mutable c_onlret: bool;  (* NL is assumed to perform as CR. *)
    mutable c_ofill: bool;   (* Use fill characters instead of delays. *)
    mutable c_ofdel: bool;   (* Fill character is DEL instead of NULL. *)
    mutable c_nldly: int;    (* Newline delay type (0-1). *)
    mutable c_crdly: int;    (* Carriage return delay type (0-3). *)
    mutable c_tabdly: int;   (* Horizontal tab delay type (0-3). *)
    mutable c_bsdly: int;    (* Backspace delay type (0-1). *)
    mutable c_vtdly: int;    (* Vertical tab delay type (0-1). *)
    mutable c_ffdly: int;    (* Form feed delay type (0-1). *)
\end{verbatim}
\begin{comment}
 Control modes: 
\end{comment}
\begin{verbatim}
    mutable c_obaud: int;    (* Output baud rate (0 means close connection).*)
    mutable c_ibaud: int;    (* Input baud rate. *)
    mutable c_csize: int;    (* Number of bits per character (5-8). *)
    mutable c_cstopb: int;   (* Number of stop bits (1-2). *)
    mutable c_cread: bool;   (* Reception is enabled. *)
    mutable c_parenb: bool;  (* Enable parity generation and detection. *)
    mutable c_parodd: bool;  (* Specify odd parity instead of even. *)
    mutable c_hupcl: bool;   (* Hang up on last close. *)
    mutable c_clocal: bool;  (* Ignore modem status lines. *)
\end{verbatim}
\begin{comment}
 Local modes: 
\end{comment}
\begin{verbatim}
    mutable c_isig: bool;    (* Generate signal on INTR, QUIT, SUSP. *)
    mutable c_icanon: bool;  (* Enable canonical processing
                                (line buffering and editing) *)
    mutable c_noflsh: bool;  (* Disable flush after INTR, QUIT, SUSP. *)
    mutable c_echo: bool;    (* Echo input characters. *)
    mutable c_echoe: bool;   (* Echo ERASE (to erase previous character). *)
    mutable c_echok: bool;   (* Echo KILL (to erase the current line). *)
    mutable c_echonl: bool;  (* Echo NL even if c_echo is not set. *)
\end{verbatim}
\begin{comment}
 Control characters: 
\end{comment}
\begin{verbatim}
    mutable c_vintr: char;   (* Interrupt character (usually ctrl-C). *)
    mutable c_vquit: char;   (* Quit character (usually ctrl-\). *)
    mutable c_verase: char;  (* Erase character (usually DEL or ctrl-H). *)
    mutable c_vkill: char;   (* Kill line character (usually ctrl-U). *)
    mutable c_veof: char;    (* End-of-file character (usually ctrl-D). *)
    mutable c_veol: char;    (* Alternate end-of-line char. (usually none). *)
    mutable c_vmin: int;     (* Minimum number of characters to read
                                before the read request is satisfied. *)
    mutable c_vtime: int;    (* Maximum read wait (in 0.1s units). *)
    mutable c_vstart: char;  (* Start character (usually ctrl-Q). *)
    mutable c_vstop: char    (* Stop character (usually ctrl-S). *)
  }
value tcgetattr: file_descr -> terminal_io
\end{verbatim}
\index{tcgetattr@\verb`tcgetattr`}%
\begin{comment}
 Return the status of the terminal referred to by the given
           file descriptor. 
\end{comment}
\begin{verbatim}
type setattr_when = TCSANOW | TCSADRAIN | TCSAFLUSH
value tcsetattr: file_descr -> setattr_when -> terminal_io -> unit
\end{verbatim}
\index{tcsetattr@\verb`tcsetattr`}%
\begin{comment}
 Set the status of the terminal referred to by the given
           file descriptor. The second argument indicates when the
           status change takes place: immediately (\verbTCSANOW),
           when all pending output has been transmitted (\verbTCSADRAIN),
           or after flushing all input that has been received but not
           read (\verbTCSAFLUSH). \verbTCSADRAIN is recommended when changing
           the output parameters; \verbTCSAFLUSH, when changing the input
           parameters. 
\end{comment}
\begin{verbatim}
value tcsendbreak: file_descr -> int -> unit
\end{verbatim}
\index{tcsendbreak@\verb`tcsendbreak`}%
\begin{comment}
 Send a break condition on the given file descriptor.
           The second argument is the duration of the break, in 0.1s units;
           0 means standard duration (0.25s). 
\end{comment}
\begin{verbatim}
value tcdrain: file_descr -> unit
\end{verbatim}
\index{tcdrain@\verb`tcdrain`}%
\begin{comment}
 Waits until all output written on the given file descriptor
           has been transmitted. 
\end{comment}
\begin{verbatim}
type flush_queue = TCIFLUSH | TCOFLUSH | TCIOFLUSH
value tcflush: file_descr -> flush_queue -> unit
\end{verbatim}
\index{tcflush@\verb`tcflush`}%
\begin{comment}
 Discard data written on the given file descriptor but not yet
           transmitted, or data received but not yet read, depending on the
           second argument: \verbTCIFLUSH flushes data received but not read,
           \verbTCOFLUSH flushes data written but not transmitted, and
           \verbTCIOFLUSH flushes both. 
\end{comment}
\begin{verbatim}
type flow_action = TCOOFF | TCOON | TCIOFF | TCION
value tcflow: file_descr -> flow_action -> unit
\end{verbatim}
\index{tcflow@\verb`tcflow`}%
\begin{comment}
 Suspend or restart reception or transmission of data on
           the given file descriptor, depending on the second argument:
           \verbTCOOFF suspends output, \verbTCOON restarts output,
           \verbTCIOFF transmits a STOP character to suspend input,
           and \verbTCION transmits a START character to restart input. 
\end{comment}
